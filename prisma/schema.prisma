// schema.prisma

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum EnumUserType {
  ADMIN
  USUARIO
}

model User {
  idUser         String       @id @default(cuid())
  name           String
  email          String       @unique
  password       String
  cpf            String       @unique
  phone          String?
  avatar         String?
  user_id_create String?
  user_id_update String?
  user_id_delete String?
  dt_delete      DateTime?
  created        DateTime     @default(now())
  updated        DateTime?    @updatedAt
  active         Boolean      @default(false)
  nivelAcessoId  Int          @default(1)
  nivel_acesso   Nivel_Acesso @relation(fields: [nivelAcessoId], references: [idNivelAcesso])
  type           EnumUserType @default(USUARIO)
  whatsappConfig WhatsAppConfig[]
  whatsappWebSessions WhatsAppWebSession[]
  transactions   Transaction[]
  expenseCategories ExpenseCategory[]
  loans          Loan[]

  errorLogs      ErrorLog[]

  @@index([idUser])
  @@index([user_id_create])
  @@index([user_id_update])
  @@index([user_id_delete])
}

model Nivel_Acesso {
  idNivelAcesso Int           @id @default(autoincrement())
  nome          String
  descricao     String?
  users         User[]
  menus         Menu_Acesso[]

  @@index([idNivelAcesso])
}

model Menu_Acesso {
  idMenuAcesso Int            @id @default(autoincrement())
  nome         String
  slug         String
  nivel_acesso Nivel_Acesso[]
  visualizar   Boolean        @default(false)
  criar        Boolean        @default(false)
  editar       Boolean        @default(false)
  excluir      Boolean        @default(false)
  relatorio    Boolean        @default(false)
}

model ErrorLog {
  id         String   @id @default(cuid())
  message    String
  stack      String?
  method     String?
  route      String?
  statusCode Int?
  userId     String?
  user       User?    @relation(fields: [userId], references: [idUser])
  userEmail  String?
  ip         String?
  userAgent  String?
  forwardedFor String?
  seen       Boolean  @default(false)
  file       String?
  line       Int?
  column     Int?
  metadata   Json?
  createdAt  DateTime @default(now())

  @@index([createdAt])
}

enum WhatsAppMessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  BUTTON
  LIST
}

enum WhatsAppMessageDirection {
  INBOUND
  OUTBOUND
}

enum WhatsAppMessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

model WhatsAppConfig {
  idConfig        String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  accessToken     String
  phoneNumberId   String
  businessAccountId String
  displayName     String?
  webhookUrl      String?
  verifyToken     String?
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  messages        WhatsAppMessage[]

  @@index([userId])
  @@index([phoneNumberId])
}

model WhatsAppWebSession {
  idSession       String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  sessionName     String
  displayName     String?
  status          String   @default("PENDING") // PENDING, CONNECTED, DISCONNECTED
  phoneNumber     String?
  qrCode          String?
  webhookUrl      String?  // URL do webhook n8n
  webhookEnabled  Boolean  @default(false) // Se o webhook está ativado
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  messages        WhatsAppMessage[]

  @@unique([userId, sessionName])
  @@index([userId])
  @@index([status])
}

model WhatsAppMessage {
  idMessage       String   @id @default(cuid())
  configId        String?
  config          WhatsAppConfig? @relation(fields: [configId], references: [idConfig], onDelete: Cascade)
  sessionId       String?
  session         WhatsAppWebSession? @relation(fields: [sessionId], references: [idSession], onDelete: Cascade)
  phoneNumber     String
  contactName     String?
  contactWaId     String?
  messageType     WhatsAppMessageType @default(TEXT)
  direction       WhatsAppMessageDirection
  status          WhatsAppMessageStatus @default(PENDING)
  content         String
  mediaUrl        String?
  caption         String?
  externalId      String?
  metadata        Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([configId])
  @@index([sessionId])
  @@index([phoneNumber])
  @@index([createdAt])
  @@index([direction])
}

enum ExpenseCategoryEnum {
  ALIMENTACAO
  TRANSPORTE
  UTILIDADES
  SAUDE
  EDUCACAO
  LAZER
  TELEFONE
  INTERNET
  SEGUROS
  IMPOSTOS
  RENDA
  INVESTIMENTOS
  OUTRAS
}

model ExpenseCategory {
  idCategory    String   @id @default(cuid())
  name          String   @unique
  description   String?
  color         String?  @default("#808080")
  icon          String?
  type          ExpenseCategoryEnum
  userId        String?
  user          User?    @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  transactions  Transaction[]
  loans         Loan[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([type])
}

model Transaction {
  idTransaction   String   @id @default(cuid())
  externalId      String?  @unique
  userId          String
  user            User     @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  date            DateTime
  value           Float
  description     String
  categoryId      String?
  category        ExpenseCategory? @relation(fields: [categoryId], references: [idCategory], onDelete: SetNull)
  isClassified    Boolean  @default(false)
  aiSuggestion    String?  // Sugestão de categoria da IA (para futuro uso do N8N)
  notes           String?
  metadata        Json?    // Para armazenar dados adicionais do CSV
  loanPayments    LoanPayment[] // Pagamentos de empréstimos associados a essa transação
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([date])
  @@index([categoryId])
  @@index([isClassified])
  @@index([externalId])
}

model Loan {
  idLoan              String   @id @default(cuid())
  userId              String
  user                User     @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  borrowerName        String   // Nome de quem pediu emprestado
  amount              Float
  categoryId          String?
  category            ExpenseCategory? @relation(fields: [categoryId], references: [idCategory], onDelete: SetNull)
  transactionId       String?  // ID da transação que originou o empréstimo (saída)
  dueDate             DateTime // Data de previsão de pagamento
  description         String?
  isPaid              Boolean  @default(false)
  paidDate            DateTime?
  notes               String?
  payments            LoanPayment[] // Histórico de pagamentos parciais
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@index([categoryId])
  @@index([dueDate])
  @@index([isPaid])
}

model LoanPayment {
  idPayment           String   @id @default(cuid())
  loanId              String
  loan                Loan     @relation(fields: [loanId], references: [idLoan], onDelete: Cascade)
  transactionId       String   // ID da transação de entrada (movimentação)
  transaction         Transaction @relation(fields: [transactionId], references: [idTransaction], onDelete: Cascade)
  amount              Float    // Quanto foi pago nessa transação para esse empréstimo
  notes               String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([loanId])
  @@index([transactionId])
}

